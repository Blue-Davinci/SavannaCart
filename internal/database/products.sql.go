// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: products.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const createNewProducts = `-- name: CreateNewProducts :one
INSERT INTO products (
    name,
    price_kes,
    category_id,
    description,
    stock_quantity
) VALUES ($1, $2, $3, $4, $5)
 RETURNING id, version, created_at, updated_at
`

type CreateNewProductsParams struct {
	Name          string
	PriceKes      string
	CategoryID    int32
	Description   sql.NullString
	StockQuantity int32
}

type CreateNewProductsRow struct {
	ID        int32
	Version   int32
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) CreateNewProducts(ctx context.Context, arg CreateNewProductsParams) (CreateNewProductsRow, error) {
	row := q.db.QueryRowContext(ctx, createNewProducts,
		arg.Name,
		arg.PriceKes,
		arg.CategoryID,
		arg.Description,
		arg.StockQuantity,
	)
	var i CreateNewProductsRow
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllProductsWithCategory = `-- name: GetAllProductsWithCategory :many
SELECT 
    count(*) OVER() AS total_count,
    p.id,
    p.name,
    p.price_kes,
    p.category_id,
    p.description,
    p.stock_quantity,
    p.version,
    p.created_at,
    p.updated_at,
    -- Category details
    c.id as category_id_info,        -- Category's own ID
    c.name as category_name,
    c.parent_id as category_parent_id -- Category's parent ID (correct!)
FROM products p
LEFT JOIN categories c ON p.category_id = c.id
WHERE ($1 = '' OR to_tsvector('simple', p.name) @@ plainto_tsquery('simple', $1))
ORDER BY p.name
LIMIT $2 OFFSET $3
`

type GetAllProductsWithCategoryParams struct {
	Column1 interface{}
	Limit   int32
	Offset  int32
}

type GetAllProductsWithCategoryRow struct {
	TotalCount       int64
	ID               int32
	Name             string
	PriceKes         string
	CategoryID       int32
	Description      sql.NullString
	StockQuantity    int32
	Version          int32
	CreatedAt        time.Time
	UpdatedAt        time.Time
	CategoryIDInfo   sql.NullInt32
	CategoryName     sql.NullString
	CategoryParentID sql.NullInt32
}

func (q *Queries) GetAllProductsWithCategory(ctx context.Context, arg GetAllProductsWithCategoryParams) ([]GetAllProductsWithCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllProductsWithCategory, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllProductsWithCategoryRow
	for rows.Next() {
		var i GetAllProductsWithCategoryRow
		if err := rows.Scan(
			&i.TotalCount,
			&i.ID,
			&i.Name,
			&i.PriceKes,
			&i.CategoryID,
			&i.Description,
			&i.StockQuantity,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryIDInfo,
			&i.CategoryName,
			&i.CategoryParentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductById = `-- name: GetProductById :one
SELECT
    id,
    name,
    price_kes,
    category_id,
    description,
    stock_quantity,
    version,
    created_at,
    updated_at
FROM products
WHERE id = $1 AND version = $2
`

type GetProductByIdParams struct {
	ID      int32
	Version int32
}

func (q *Queries) GetProductById(ctx context.Context, arg GetProductByIdParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProductById, arg.ID, arg.Version)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PriceKes,
		&i.CategoryID,
		&i.Description,
		&i.StockQuantity,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
