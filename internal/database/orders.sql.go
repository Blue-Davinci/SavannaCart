// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: orders.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const checkProductAvailability = `-- name: CheckProductAvailability :one
SELECT 
    id,
    name,
    stock_quantity,
    CASE 
        WHEN stock_quantity >= $2 THEN true
        ELSE false
    END as is_available
FROM products
WHERE id = $1
`

type CheckProductAvailabilityParams struct {
	ID            int32
	StockQuantity int32
}

type CheckProductAvailabilityRow struct {
	ID            int32
	Name          string
	StockQuantity int32
	IsAvailable   bool
}

func (q *Queries) CheckProductAvailability(ctx context.Context, arg CheckProductAvailabilityParams) (CheckProductAvailabilityRow, error) {
	row := q.db.QueryRowContext(ctx, checkProductAvailability, arg.ID, arg.StockQuantity)
	var i CheckProductAvailabilityRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.StockQuantity,
		&i.IsAvailable,
	)
	return i, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (
    user_id,
    total_kes,
    status
) VALUES ($1, $2, $3)
RETURNING id, user_id, total_kes, status, version, created_at, updated_at
`

type CreateOrderParams struct {
	UserID   int32
	TotalKes string
	Status   string
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, createOrder, arg.UserID, arg.TotalKes, arg.Status)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TotalKes,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO order_items (
    order_id,
    product_id,
    quantity,
    unit_price_kes
) VALUES ($1, $2, $3, $4)
RETURNING id, order_id, product_id, quantity, unit_price_kes, created_at
`

type CreateOrderItemParams struct {
	OrderID      int32
	ProductID    int32
	Quantity     int32
	UnitPriceKes string
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (OrderItem, error) {
	row := q.db.QueryRowContext(ctx, createOrderItem,
		arg.OrderID,
		arg.ProductID,
		arg.Quantity,
		arg.UnitPriceKes,
	)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProductID,
		&i.Quantity,
		&i.UnitPriceKes,
		&i.CreatedAt,
	)
	return i, err
}

const getAllOrdersWithItems = `-- name: GetAllOrdersWithItems :many
SELECT 
    o.id as order_id,
    o.user_id,
    u.first_name as user_first_name,
    u.last_name as user_last_name,
    u.email as user_email,
    o.total_kes,
    o.status,
    o.version,
    o.created_at as order_created_at,
    o.updated_at as order_updated_at,
    oi.id as order_item_id,
    oi.product_id,
    p.name as product_name,
    oi.quantity,
    oi.unit_price_kes,
    oi.created_at as item_created_at,
    count(*) OVER() AS total_count
FROM orders o
INNER JOIN users u ON o.user_id = u.id
LEFT JOIN order_items oi ON o.id = oi.order_id
LEFT JOIN products p ON oi.product_id = p.id
WHERE ($1 = '' OR o.status = $1)
ORDER BY o.created_at DESC, oi.id ASC
LIMIT $2 OFFSET $3
`

type GetAllOrdersWithItemsParams struct {
	Column1 interface{}
	Limit   int32
	Offset  int32
}

type GetAllOrdersWithItemsRow struct {
	OrderID        int32
	UserID         int32
	UserFirstName  string
	UserLastName   string
	UserEmail      string
	TotalKes       string
	Status         string
	Version        int32
	OrderCreatedAt time.Time
	OrderUpdatedAt time.Time
	OrderItemID    sql.NullInt32
	ProductID      sql.NullInt32
	ProductName    sql.NullString
	Quantity       sql.NullInt32
	UnitPriceKes   sql.NullString
	ItemCreatedAt  sql.NullTime
	TotalCount     int64
}

func (q *Queries) GetAllOrdersWithItems(ctx context.Context, arg GetAllOrdersWithItemsParams) ([]GetAllOrdersWithItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllOrdersWithItems, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllOrdersWithItemsRow
	for rows.Next() {
		var i GetAllOrdersWithItemsRow
		if err := rows.Scan(
			&i.OrderID,
			&i.UserID,
			&i.UserFirstName,
			&i.UserLastName,
			&i.UserEmail,
			&i.TotalKes,
			&i.Status,
			&i.Version,
			&i.OrderCreatedAt,
			&i.OrderUpdatedAt,
			&i.OrderItemID,
			&i.ProductID,
			&i.ProductName,
			&i.Quantity,
			&i.UnitPriceKes,
			&i.ItemCreatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderById = `-- name: GetOrderById :one
SELECT 
    id,
    user_id,
    total_kes,
    status,
    version,
    created_at,
    updated_at
FROM orders
WHERE id = $1
`

func (q *Queries) GetOrderById(ctx context.Context, id int32) (Order, error) {
	row := q.db.QueryRowContext(ctx, getOrderById, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TotalKes,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrderByIdWithItems = `-- name: GetOrderByIdWithItems :many
SELECT 
    o.id as order_id,
    o.user_id,
    o.total_kes,
    o.status,
    o.version,
    o.created_at as order_created_at,
    o.updated_at as order_updated_at,
    oi.id as order_item_id,
    oi.product_id,
    p.name as product_name,
    p.price_kes as current_price,
    oi.quantity,
    oi.unit_price_kes,
    oi.created_at as item_created_at
FROM orders o
LEFT JOIN order_items oi ON o.id = oi.order_id
LEFT JOIN products p ON oi.product_id = p.id
WHERE o.id = $1
ORDER BY oi.id ASC
`

type GetOrderByIdWithItemsRow struct {
	OrderID        int32
	UserID         int32
	TotalKes       string
	Status         string
	Version        int32
	OrderCreatedAt time.Time
	OrderUpdatedAt time.Time
	OrderItemID    sql.NullInt32
	ProductID      sql.NullInt32
	ProductName    sql.NullString
	CurrentPrice   sql.NullString
	Quantity       sql.NullInt32
	UnitPriceKes   sql.NullString
	ItemCreatedAt  sql.NullTime
}

func (q *Queries) GetOrderByIdWithItems(ctx context.Context, id int32) ([]GetOrderByIdWithItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrderByIdWithItems, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderByIdWithItemsRow
	for rows.Next() {
		var i GetOrderByIdWithItemsRow
		if err := rows.Scan(
			&i.OrderID,
			&i.UserID,
			&i.TotalKes,
			&i.Status,
			&i.Version,
			&i.OrderCreatedAt,
			&i.OrderUpdatedAt,
			&i.OrderItemID,
			&i.ProductID,
			&i.ProductName,
			&i.CurrentPrice,
			&i.Quantity,
			&i.UnitPriceKes,
			&i.ItemCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderStatistics = `-- name: GetOrderStatistics :one
SELECT 
    COUNT(*) as total_orders,
    COUNT(CASE WHEN status = 'PLACED' THEN 1 END) as placed_orders,
    COUNT(CASE WHEN status = 'PROCESSING' THEN 1 END) as processing_orders,
    COUNT(CASE WHEN status = 'SHIPPED' THEN 1 END) as shipped_orders,
    COUNT(CASE WHEN status = 'DELIVERED' THEN 1 END) as delivered_orders,
    COUNT(CASE WHEN status = 'CANCELLED' THEN 1 END) as cancelled_orders,
    COALESCE(SUM(total_kes), 0)::text as total_revenue,
    COALESCE(AVG(total_kes), 0)::text as average_order_value
FROM orders
WHERE created_at >= $1 AND created_at <= $2
`

type GetOrderStatisticsParams struct {
	CreatedAt   time.Time
	CreatedAt_2 time.Time
}

type GetOrderStatisticsRow struct {
	TotalOrders       int64
	PlacedOrders      int64
	ProcessingOrders  int64
	ShippedOrders     int64
	DeliveredOrders   int64
	CancelledOrders   int64
	TotalRevenue      string
	AverageOrderValue string
}

func (q *Queries) GetOrderStatistics(ctx context.Context, arg GetOrderStatisticsParams) (GetOrderStatisticsRow, error) {
	row := q.db.QueryRowContext(ctx, getOrderStatistics, arg.CreatedAt, arg.CreatedAt_2)
	var i GetOrderStatisticsRow
	err := row.Scan(
		&i.TotalOrders,
		&i.PlacedOrders,
		&i.ProcessingOrders,
		&i.ShippedOrders,
		&i.DeliveredOrders,
		&i.CancelledOrders,
		&i.TotalRevenue,
		&i.AverageOrderValue,
	)
	return i, err
}

const getUserOrdersWithItems = `-- name: GetUserOrdersWithItems :many
SELECT 
    o.id as order_id,
    o.user_id,
    o.total_kes,
    o.status,
    o.version,
    o.created_at as order_created_at,
    o.updated_at as order_updated_at,
    oi.id as order_item_id,
    oi.product_id,
    p.name as product_name,
    oi.quantity,
    oi.unit_price_kes,
    oi.created_at as item_created_at,
    count(*) OVER() AS total_count
FROM orders o
LEFT JOIN order_items oi ON o.id = oi.order_id
LEFT JOIN products p ON oi.product_id = p.id
WHERE o.user_id = $1
ORDER BY o.created_at DESC, oi.id ASC
LIMIT $2 OFFSET $3
`

type GetUserOrdersWithItemsParams struct {
	UserID int32
	Limit  int32
	Offset int32
}

type GetUserOrdersWithItemsRow struct {
	OrderID        int32
	UserID         int32
	TotalKes       string
	Status         string
	Version        int32
	OrderCreatedAt time.Time
	OrderUpdatedAt time.Time
	OrderItemID    sql.NullInt32
	ProductID      sql.NullInt32
	ProductName    sql.NullString
	Quantity       sql.NullInt32
	UnitPriceKes   sql.NullString
	ItemCreatedAt  sql.NullTime
	TotalCount     int64
}

func (q *Queries) GetUserOrdersWithItems(ctx context.Context, arg GetUserOrdersWithItemsParams) ([]GetUserOrdersWithItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserOrdersWithItems, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserOrdersWithItemsRow
	for rows.Next() {
		var i GetUserOrdersWithItemsRow
		if err := rows.Scan(
			&i.OrderID,
			&i.UserID,
			&i.TotalKes,
			&i.Status,
			&i.Version,
			&i.OrderCreatedAt,
			&i.OrderUpdatedAt,
			&i.OrderItemID,
			&i.ProductID,
			&i.ProductName,
			&i.Quantity,
			&i.UnitPriceKes,
			&i.ItemCreatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrderStatus = `-- name: UpdateOrderStatus :one
UPDATE orders
SET 
    status = $2,
    version = version + 1,
    updated_at = NOW()
WHERE id = $1 AND version = $3
RETURNING id, user_id, total_kes, status, version, created_at, updated_at
`

type UpdateOrderStatusParams struct {
	ID      int32
	Status  string
	Version int32
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, updateOrderStatus, arg.ID, arg.Status, arg.Version)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TotalKes,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
